# Subscription Server Specification

This document specifies a subscription server that lets **creators** offer subscriptions to **subscribers**, with recurring fees, billing lifecycle management, and revenue accounting.

## Goals
- Allow any user to become a creator and publish subscription offerings.
- Allow any user to subscribe to a creator with recurring billing (monthly by default).
- Support subscription lifecycle: trial (optional), active, past_due, canceled, expired.
- Provide payout accounting and creator earnings visibility.
- Keep PCI scope out of the core service by delegating payment processing to a payment provider (Stripe/PayPal/CCBill, etc.).

## Non-goals
- Direct card data handling or PCI compliance tooling inside this service.
- Building a full marketplace UI (this spec covers API + backend services).

## Actors & Roles
- **Creator**: user who offers subscription plans.
- **Subscriber**: user who subscribes to a creator's plan.
- **Platform**: the service that manages plans, billing state, and payouts.
- **Payment Provider**: external billing system that executes recurring charges and sends webhooks.

## Key Concepts
- **Plan**: a subscription offering by a creator (price, billing interval, perks).
- **Subscription**: an agreement between a subscriber and a creator tied to a plan.
- **Invoice**: a billing record generated by the payment provider for each period.
- **Ledger**: internal accounting of charges, fees, and payouts.

## Functional Requirements
### Creator capabilities
1. Create, update, archive plans.
2. View subscribers and subscription status.
3. See earnings and payout history.

### Subscriber capabilities
1. Browse and purchase creator plans.
2. Manage subscription status (cancel, renew).
3. View payment history and next billing date.

### Platform capabilities
1. Sync subscription status via webhooks.
2. Handle failed payments with retry and dunning policies.
3. Calculate platform fees and creator payouts.
4. Support refunds/chargebacks and reverse ledger entries.

## High-level Architecture
```
Client UI
  |  REST/GraphQL
  v
Subscription Service  <---->  Auth Service (user identity)
  |                           
  |  Webhooks                 
  v                           
Payment Provider (Stripe/PayPal/CCBill)
```

## Data Model (Logical)
### User
- id (string)
- display_name
- email
- role flags (creator_enabled)
- created_at

### Plan
- id
- creator_id (FK -> User)
- name
- description
- price_cents
- currency
- interval (month/year)
- status (active/archived)
- metadata (JSON)
- created_at
- updated_at

### Subscription
- id
- plan_id
- creator_id
- subscriber_id
- provider (stripe/paypal/ccbill)
- provider_subscription_id
- status (trialing/active/past_due/canceled/expired)
- start_at
- current_period_end
- cancel_at_period_end (bool)
- created_at
- updated_at

### Invoice
- id
- subscription_id
- provider_invoice_id
- amount_cents
- currency
- status (paid/failed/refunded)
- period_start
- period_end
- created_at

### LedgerEntry
- id
- subscription_id
- creator_id
- subscriber_id
- entry_type (charge/fee/payout/refund/chargeback)
- amount_cents
- currency
- metadata
- created_at

### Payout
- id
- creator_id
- amount_cents
- currency
- status (pending/paid/failed)
- period_start
- period_end
- provider_payout_id
- created_at

## API Surface (REST)
### Plans
- `POST /api/creators/{creator_id}/plans`
- `GET /api/creators/{creator_id}/plans`
- `PATCH /api/plans/{plan_id}`
- `POST /api/plans/{plan_id}/archive`

### Subscriptions
- `POST /api/plans/{plan_id}/subscribe`
- `GET /api/subscriptions?subscriber_id=...`
- `GET /api/creators/{creator_id}/subscriptions`
- `POST /api/subscriptions/{subscription_id}/cancel`
- `POST /api/subscriptions/{subscription_id}/resume`

### Billing & Earnings
- `GET /api/subscriptions/{subscription_id}/invoices`
- `GET /api/creators/{creator_id}/earnings`
- `GET /api/creators/{creator_id}/payouts`

### Webhooks
- `POST /api/billing/webhooks/{provider}`

## Subscription Flow (Stripe Example)
1. Subscriber selects plan.
2. Client calls `POST /api/plans/{plan_id}/subscribe`.
3. Server creates a provider subscription and returns client approval URL if needed.
4. Provider sends webhooks for `subscription.created`, `invoice.paid`, `invoice.payment_failed`.
5. Server updates subscription status and ledger entries.

## Payment Provider Abstraction
Define a provider interface so billing logic is uniform:
- `create_subscription(plan, subscriber, payment_method)`
- `cancel_subscription(provider_subscription_id)`
- `list_invoices(provider_subscription_id)`
- `verify_webhook(request)`

## State Transitions
- `trialing` → `active` on first successful invoice.
- `active` → `past_due` on payment failure.
- `past_due` → `active` on successful retry.
- `active|past_due` → `canceled` on user cancel.
- `canceled` → `expired` when period ends.

## Security & Compliance
- Require auth for all plan and subscription actions.
- Use webhook signature verification for provider events.
- Store only provider tokens/IDs, never raw card data.
- Maintain audit trails for subscription status changes.

## Observability
- Log all webhook events (dedupe keys).
- Emit metrics for active subscribers, churn, MRR, failed payments.

## Edge Cases
- Creator deletes account: cancel or migrate subscriptions.
- Subscriber disputes: create refund + ledger reversal.
- Proration: support optional pro-rated upgrades/downgrades.

## Open Questions
- Multi-currency support scope?
- Revenue share/fees configuration per creator vs global?
- Payout schedule (weekly/monthly) and minimum thresholds?
